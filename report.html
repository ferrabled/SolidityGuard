
        <!DOCTYPE html>
        <html>
        <head>
        <link rel="stylesheet" href="utils/style.css">
        <title>Report</title>
        </head>
        <body>
    
        <div class="pageHeader">
            <div class="iconName"> <img src="icon.png" alt="Logo" width="40" height="40"> Solidity Guard </div>
            <div class="separator"> </div>
            <a href="#dashboard"> Dashboard </a>
            <a href="#findings"> Findings </a>
            <a href="#requires"> Requires </a>
        </div>
        
        <div class="container">
        <h1>Report</h1>
        <div class="SGuardHeader">
            <div class='Text'>
                <p>This is an automated report created with the tool <b>Solidity Guard</b>. This tool searches for vulnerabilities in the source code of Solidity Smart contracts with static analysis by traversing its Abstract Syntax Tree (AST). There are several detectors developed, that can find:
                <u>Reentrancy</u> vulnerabilities, unchecked low level calls, <u>selfdestructs</u> not protected, <u>tx.origin</u> usage, possible <u>overflows & underflows</u> vulnerabilities and <u>timestamps</u> calls. 
                Some advices to the developer are given as well, as reminders to review the integrity and correctness of <u>delegatecall</u>, and possible <u>denial of services</u> findings, due to for and while loops.
                Another functionality created is a <u>require checker</u>, that will recommend the use of a modifier when a require is found 3 or more times. 
                The findings will be shown in the next dashboard. </p>   
            </div>
            <div class='logo'>
                <img src="icon.png" alt="Logo" width="100" height="100">
                <div class='Links'>
                    <a href="github.com/ferrabled/SolidiyGuard">Github</a>
                    <a href="mailto:ferrabled@gmail.com">Contact</a>
                </div>
            </div>
        </div>
        </div>
    
        <div class="container" id="dashboard">
            <h2>Dashboard</h2>
            <div class="dash-row">
            <div class="analyzed">
                <div class="dcard">
                    <h3>Lines of code</h3>
                    <h2>26</h2>
                </div>
                <div class="dcard">
                    <h3>Contracts</h3>
                    <h2>1</h2>
                </div>
                <div class="dcard">
                    <h3>Functions</h3>
                    <h2>2</h2>
                </div>
            </div>
            <div class="findings">
                <div class="dcard">
                    <h3>Emits</h3>
                    <h2>2</h2>
                </div>
                <div class="dcard">
                    <h3>Requires</h3>
                    <h2>1</h2>
                </div>
                <div class="dcard">
                    <h3>Repeated Requires</h3>
                    <h2>0</h2>
                </div>
            </div>
            <div class="findings">
                <div class="dcard">
                    <h3>Findings</h3>
                    <h2>6</h2>
                </div>
                <div class="dcard">
                    <h3>Vulns.</h3>
                    <h2>2</h2>
                </div>
                <div class="dcard">
                    <h3>Warnings</h3>
                    <h2>4</h2>
                </div>
            </div>
            </div>
        </div>
    
    
        <div class="container" id="findings">
            <h2>Findings</h2> 
    
                <div class="finding">
                    <div class="title">
                        <h2>Low-level call, unchecked return statement Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The unchecked call vulnerability refers to a security weakness in Solidity smart contracts where the return value of certain low-level functions, such as 'call', 'callcode', 'delegatecall', 'send', and 'staticcall', is not properly checked. These functions allow contracts to interact with other contracts, but if the return value is not adequately verified, it can lead to unexpected behaviors and potential vulnerabilities. When an unchecked call is made, the contract does not verify the success or failure of the called function. This can result in various issues, including reentrancy attacks, where an attacker exploits the unchecked call to recursively call back into the calling contract and manipulate its state. Additionally, if the return value is not validated, it could lead to erroneous assumptions about the execution status or data received, potentially causing critical security vulnerabilities.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract uncheckedCall inside the function uncheckedCall (Line: 13)</p><pre>    function refundAll() public {
        emit RefundAll(refundAddresses.length);
        for(uint x; x < refundAddresses.length; x++) { // arbitrary length iteration based on how many addresses participated
            require(payable(refundAddresses[x]).send(refunds[refundAddresses[x]])); // doubly bad, now a single failure on send will hold up all funds
        }
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Low-level call, unchecked return statement Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The unchecked call vulnerability refers to a security weakness in Solidity smart contracts where the return value of certain low-level functions, such as 'call', 'callcode', 'delegatecall', 'send', and 'staticcall', is not properly checked. These functions allow contracts to interact with other contracts, but if the return value is not adequately verified, it can lead to unexpected behaviors and potential vulnerabilities. When an unchecked call is made, the contract does not verify the success or failure of the called function. This can result in various issues, including reentrancy attacks, where an attacker exploits the unchecked call to recursively call back into the calling contract and manipulate its state. Additionally, if the return value is not validated, it could lead to erroneous assumptions about the execution status or data received, potentially causing critical security vulnerabilities.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract uncheckedCall inside the function uncheckedCall (Line: 22)</p><pre>    function refundAll2() public {
        emit RefundAll(refundAddresses.length);
        uint x = 0;
        while(refundAddresses.length > 5) { // arbitrary length iteration based on how many addresses participated
            require(payable(refundAddresses[x]).send(refunds[refundAddresses[x]])); // doubly bad, now a single failure on send will hold up all funds
            x++;
        }
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Save Gas: change 'send' for 'call'</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>When using 'send', a fixed amount of gas is allocated for the execution of the called contract. This function do not allow for specifying a custom amount of gas or handling the return value, limiting their flexibility. By changing the 'send' function by 'call', developers can optimize gas usage, handle exceptions, and react accordingly based on the return value.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract send inside the function send (Line: 13)</p><pre>    function refundAll() public {
        emit RefundAll(refundAddresses.length);
        for(uint x; x < refundAddresses.length; x++) { // arbitrary length iteration based on how many addresses participated
            require(payable(refundAddresses[x]).send(refunds[refundAddresses[x]])); // doubly bad, now a single failure on send will hold up all funds
        }
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Save Gas: change 'send' for 'call'</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>When using 'send', a fixed amount of gas is allocated for the execution of the called contract. This function do not allow for specifying a custom amount of gas or handling the return value, limiting their flexibility. By changing the 'send' function by 'call', developers can optimize gas usage, handle exceptions, and react accordingly based on the return value.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract send inside the function send (Line: 22)</p><pre>    function refundAll2() public {
        emit RefundAll(refundAddresses.length);
        uint x = 0;
        while(refundAddresses.length > 5) { // arbitrary length iteration based on how many addresses participated
            require(payable(refundAddresses[x]).send(refunds[refundAddresses[x]])); // doubly bad, now a single failure on send will hold up all funds
            x++;
        }
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Denial of Service (DoS) by for loop</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>This vulnerability arises when a for loop is used to iterate over a large number of iterations, causing excessive computational overhead and consuming an excessive amount of gas. If the gas limit is exceeded, the function won't be executed and can lead to funds loss. If the iterations of the loop could surpass the maximum usage of gas, it is advisable to switch to a pull-over-push design. In this design, instead of using a loop, a public function is created to perform the functionality of each iteration, allowing each person to execute it.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract dos inside the function dos (Line: 12)</p><pre>    function refundAll() public {
        emit RefundAll(refundAddresses.length);
        for(uint x; x < refundAddresses.length; x++) { // arbitrary length iteration based on how many addresses participated
            require(payable(refundAddresses[x]).send(refunds[refundAddresses[x]])); // doubly bad, now a single failure on send will hold up all funds
        }
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Denial of Service (DoS) by while loop</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>This vulnerability arises when a while loop is used to iterate over a large number of iterations, causing excessive computational overhead and consuming an excessive amount of gas. If the gas limit is exceeded, the function won't be executed and can lead to funds loss. If the iterations of the loop could surpass the maximum usage of gas, it is advisable to switch to a pull-over-push design. In this design, instead of using a loop, a public function is created to perform the functionality of each iteration, allowing each person to execute it.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract dos inside the function dos (Line: 21)</p><pre>    function refundAll2() public {
        emit RefundAll(refundAddresses.length);
        uint x = 0;
        while(refundAddresses.length > 5) { // arbitrary length iteration based on how many addresses participated
            require(payable(refundAddresses[x]).send(refunds[refundAddresses[x]])); // doubly bad, now a single failure on send will hold up all funds
            x++;
        }
    }
</pre></div>
        </div>
    
        </div>
        
        <div class="container" id="requires">
            <h2>Requires</h2>
            <div class="info-row">
                <h4>The following requires have been found several times. It is advisabe to replace them with a modifier</h4>
            </div>
        <div class="requires-grid">
    
                <div class="require_card">
                    <p> No require has been found repeated more than 3 times in the contract </p>
                </div>
        
            </div>
        </div>
    
        </body>
        </html>
    