
        <!DOCTYPE html>
        <html lang="en" xml:lang="en">
        <head>
        <link rel="stylesheet" href="utils/style.css">
        <title>Report</title>
        </head>
        <body>
    
        <div class="pageHeader">
            <div class="iconName"> <img src="icon.png" alt="Logo" width="40" height="40"> Solidity Guard </div>
            <div class="separator"> </div>
            <a href="#dashboard"> Dashboard </a>
            <a href="#findings"> Findings </a>
            <a href="#requires"> Requires </a>
        </div>
        
        <div class="container">
        <h1>Report</h1>
        <div class="SGuardHeader">
            <div class='Text'>
                <p>This is an automated report created with the tool <b>Solidity Guard</b>. This tool searches for vulnerabilities in the source code of Solidity Smart contracts with static analysis by traversing its Abstract Syntax Tree (AST). There are several detectors developed, that can find:
                <u>Reentrancy</u> vulnerabilities, unchecked low level calls, <u>selfdestructs</u> not protected, <u>tx.origin</u> usage, possible <u>overflows & underflows</u> vulnerabilities and <u>timestamps</u> calls. 
                Some advices to the developer are given as well, as reminders to review the integrity and correctness of <u>delegatecall</u>, and possible <u>denial of services</u> findings, due to for and while loops.
                Another functionality created is a <u>require checker</u>, that will recommend the use of a modifier when a require is found 3 or more times. 
                The findings will be shown in the next dashboard. </p>   
            </div>
            <div class='logo'>
                <img src="icon.png" alt="Logo" width="100" height="100">
                <div class='Links'>
                    <a href="github.com/ferrabled/SolidiyGuard">Github</a>
                    <a href="mailto:ferrabled@gmail.com">Contact</a>
                </div>
            </div>
        </div>
        </div>
    
        <div class="container" id="dashboard">
            <h2>Dashboard</h2>
            <div class="dash-row">
            <div class="analyzed">
                <div class="dcard">
                    <h3>Lines of code</h3>
                    <h2>505</h2>
                </div>
                <div class="dcard">
                    <h3>Contracts</h3>
                    <h2>14</h2>
                </div>
                <div class="dcard">
                    <h3>Functions</h3>
                    <h2>42</h2>
                </div>
            </div>
            <div class="findings">
                <div class="dcard">
                    <h3>Emits</h3>
                    <h2>0</h2>
                </div>
                <div class="dcard">
                    <h3>Requires</h3>
                    <h2>17</h2>
                </div>
                <div class="dcard">
                    <h3>Repeated Requires</h3>
                    <h2>5</h2>
                </div>
            </div>
            <div class="findings">
                <div class="dcard">
                    <h3>Findings</h3>
                    <h2>48</h2>
                </div>
                <div class="dcard">
                    <h3>Vulns.</h3>
                    <h2>29</h2>
                </div>
                <div class="dcard">
                    <h3>Warnings</h3>
                    <h2>19</h2>
                </div>
            </div>
            </div>
        </div>
    
    
        <div class="container" id="findings">
            <h2>Findings</h2> 
    
                <div class="finding">
                    <div class="title">
                        <h2>Reentrancy Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Reentrancy vulnerability is a security flaw found in Solidity smart contracts where a contract can be repeatedly called before the previous call has completed, potentially allowing malicious actors to manipulate the contract's state or control its execution flow. This vulnerability arises when a contract interacts with external contracts and fails to properly manage the order of execution and state changes. By exploiting reentrancy, an attacker can repeatedly call a contract's function and invoke their own malicious callback, potentially draining funds or causing undesired effects in the contract's logic. Proper handling of external calls and state management is crucial.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract reentrancy inside the function reentrancy (Line: 23)</p><pre>    function withdrawAll() external {
        uint256 balance = getUserBalance(msg.sender);
        require(balance > 0, "Insufficient balance");

        (bool success, ) = msg.sender.call{value: balance}("");
        require(success, "Failed to send Ether");

        userBalances[msg.sender] = 0;
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Reentrancy Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Reentrancy vulnerability is a security flaw found in Solidity smart contracts where a contract can be repeatedly called before the previous call has completed, potentially allowing malicious actors to manipulate the contract's state or control its execution flow. This vulnerability arises when a contract interacts with external contracts and fails to properly manage the order of execution and state changes. By exploiting reentrancy, an attacker can repeatedly call a contract's function and invoke their own malicious callback, potentially draining funds or causing undesired effects in the contract's logic. Proper handling of external calls and state management is crucial.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract reentrancy inside the function reentrancy (Line: 65)</p><pre>function withdraw(uint amount) payable public returns (bool) {
    require(!lockBalances && amount > 0 && balances[msg.sender] >= amount);
    require(lockBalances);
    lockBalances = true;
    (bool success, ) = msg.sender.call{value:balances[msg.sender]}("");

    if (success) {
      balances[msg.sender] -= amount;
    }

    lockBalances = false;
    return true;
}
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Reentrancy Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Reentrancy vulnerability is a security flaw found in Solidity smart contracts where a contract can be repeatedly called before the previous call has completed, potentially allowing malicious actors to manipulate the contract's state or control its execution flow. This vulnerability arises when a contract interacts with external contracts and fails to properly manage the order of execution and state changes. By exploiting reentrancy, an attacker can repeatedly call a contract's function and invoke their own malicious callback, potentially draining funds or causing undesired effects in the contract's logic. Proper handling of external calls and state management is crucial.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract reentrancy inside the function reentrancy (Line: 99)</p><pre>    function withdrawAll() external {
        uint256 balance = getUserBalance(msg.sender);
        require(balance > 0, "Insufficient balance");

        (bool success, ) = msg.sender.call{value: balance}("");
        require(success, "Failed to send Ether");

        userBalances[msg.sender] = 0;
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Reentrancy Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Reentrancy vulnerability is a security flaw found in Solidity smart contracts where a contract can be repeatedly called before the previous call has completed, potentially allowing malicious actors to manipulate the contract's state or control its execution flow. This vulnerability arises when a contract interacts with external contracts and fails to properly manage the order of execution and state changes. By exploiting reentrancy, an attacker can repeatedly call a contract's function and invoke their own malicious callback, potentially draining funds or causing undesired effects in the contract's logic. Proper handling of external calls and state management is crucial.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract reentrancy inside the function reentrancy (Line: 148)</p><pre>    function claimReward() public {
        require(msg.sender == winner, "Not winner");

        (bool sent, ) = msg.sender.call{value: address(this).balance}("");
        require(sent, "Failed to send Ether");
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Reentrancy Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Reentrancy vulnerability is a security flaw found in Solidity smart contracts where a contract can be repeatedly called before the previous call has completed, potentially allowing malicious actors to manipulate the contract's state or control its execution flow. This vulnerability arises when a contract interacts with external contracts and fails to properly manage the order of execution and state changes. By exploiting reentrancy, an attacker can repeatedly call a contract's function and invoke their own malicious callback, potentially draining funds or causing undesired effects in the contract's logic. Proper handling of external calls and state management is crucial.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract reentrancy inside the function reentrancy (Line: 215)</p><pre>    function claimReward() public {
        require(msg.sender == winner, "Not winner");

        (bool sent, ) = msg.sender.call{value: address(this).balance}("");
        require(sent, "Failed to send Ether");
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Reentrancy Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Reentrancy vulnerability is a security flaw found in Solidity smart contracts where a contract can be repeatedly called before the previous call has completed, potentially allowing malicious actors to manipulate the contract's state or control its execution flow. This vulnerability arises when a contract interacts with external contracts and fails to properly manage the order of execution and state changes. By exploiting reentrancy, an attacker can repeatedly call a contract's function and invoke their own malicious callback, potentially draining funds or causing undesired effects in the contract's logic. Proper handling of external calls and state management is crucial.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract reentrancy inside the function reentrancy (Line: 311)</p><pre>    function callVuln() public {
        msg.sender.call{value: winAmount}("");
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Reentrancy Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Reentrancy vulnerability is a security flaw found in Solidity smart contracts where a contract can be repeatedly called before the previous call has completed, potentially allowing malicious actors to manipulate the contract's state or control its execution flow. This vulnerability arises when a contract interacts with external contracts and fails to properly manage the order of execution and state changes. By exploiting reentrancy, an attacker can repeatedly call a contract's function and invoke their own malicious callback, potentially draining funds or causing undesired effects in the contract's logic. Proper handling of external calls and state management is crucial.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract reentrancy inside the function reentrancy (Line: 320)</p><pre>    function call() public {
        (bool success, ) = msg.sender.call{value: winAmount}("");
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Reentrancy Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Reentrancy vulnerability is a security flaw found in Solidity smart contracts where a contract can be repeatedly called before the previous call has completed, potentially allowing malicious actors to manipulate the contract's state or control its execution flow. This vulnerability arises when a contract interacts with external contracts and fails to properly manage the order of execution and state changes. By exploiting reentrancy, an attacker can repeatedly call a contract's function and invoke their own malicious callback, potentially draining funds or causing undesired effects in the contract's logic. Proper handling of external calls and state management is crucial.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract reentrancy inside the function reentrancy (Line: 364)</p><pre>    function spin() external payable {
        require(msg.value == 10 ether); // must send 10 ether to play
        require(block.number != pastBlockTime); // only 1 transaction per block

        pastBlockTime = block.timestamp;

        if (block.number % 15 == 0) {
            (bool sent, ) = msg.sender.call{value: address(this).balance}("");
            require(sent, "Failed to send Ether");
        }
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Reentrancy Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Reentrancy vulnerability is a security flaw found in Solidity smart contracts where a contract can be repeatedly called before the previous call has completed, potentially allowing malicious actors to manipulate the contract's state or control its execution flow. This vulnerability arises when a contract interacts with external contracts and fails to properly manage the order of execution and state changes. By exploiting reentrancy, an attacker can repeatedly call a contract's function and invoke their own malicious callback, potentially draining funds or causing undesired effects in the contract's logic. Proper handling of external calls and state management is crucial.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract reentrancy inside the function reentrancy (Line: 389)</p><pre>    function transfer(address payable _to, uint _amount) public {
        require(tx.origin == owner, "Not owner");

        (bool sent, ) = _to.call{value: _amount}("");
        require(sent, "Failed to send Ether");
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Low-level call, unchecked return statement Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The unchecked call vulnerability refers to a security weakness in Solidity smart contracts where the return value of certain low-level functions, such as 'call', 'callcode', 'delegatecall', 'send', and 'staticcall', is not properly checked. These functions allow contracts to interact with other contracts, but if the return value is not adequately verified, it can lead to unexpected behaviors and potential vulnerabilities. When an unchecked call is made, the contract does not verify the success or failure of the called function. This can result in various issues, including reentrancy attacks, where an attacker exploits the unchecked call to recursively call back into the calling contract and manipulate its state. Additionally, if the return value is not validated, it could lead to erroneous assumptions about the execution status or data received, potentially causing critical security vulnerabilities.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract uncheckedCall inside the function uncheckedCall (Line: 257)</p><pre>    function withdraw() public payable{
        withdrawalCounter += 1;
        // this sets calculatedFibNumber
        fibonacciLibrary.delegatecall(abi.encode(fibSig, withdrawalCounter));
        payable(msg.sender).transfer(calculatedFibNumber * 1 ether);
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Low-level call, unchecked return statement Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The unchecked call vulnerability refers to a security weakness in Solidity smart contracts where the return value of certain low-level functions, such as 'call', 'callcode', 'delegatecall', 'send', and 'staticcall', is not properly checked. These functions allow contracts to interact with other contracts, but if the return value is not adequately verified, it can lead to unexpected behaviors and potential vulnerabilities. When an unchecked call is made, the contract does not verify the success or failure of the called function. This can result in various issues, including reentrancy attacks, where an attacker exploits the unchecked call to recursively call back into the calling contract and manipulate its state. Additionally, if the return value is not validated, it could lead to erroneous assumptions about the execution status or data received, potentially causing critical security vulnerabilities.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract uncheckedCall inside the function uncheckedCall (Line: 263)</p><pre>    function pp() public {
        fibonacciLibrary.delegatecall(msg.data);
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Low-level call, unchecked return statement Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The unchecked call vulnerability refers to a security weakness in Solidity smart contracts where the return value of certain low-level functions, such as 'call', 'callcode', 'delegatecall', 'send', and 'staticcall', is not properly checked. These functions allow contracts to interact with other contracts, but if the return value is not adequately verified, it can lead to unexpected behaviors and potential vulnerabilities. When an unchecked call is made, the contract does not verify the success or failure of the called function. This can result in various issues, including reentrancy attacks, where an attacker exploits the unchecked call to recursively call back into the calling contract and manipulate its state. Additionally, if the return value is not validated, it could lead to erroneous assumptions about the execution status or data received, potentially causing critical security vulnerabilities.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract uncheckedCall inside the function uncheckedCall (Line: 280)</p><pre>    function doSomething(uint _num) public {
        lib.delegatecall(abi.encodeWithSignature("doSomething(uint256)", _num));
        address x = tx.origin;
        //function transfer
        payable(x).transfer(2);
        payable(x).send(2);

    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Low-level call, unchecked return statement Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The unchecked call vulnerability refers to a security weakness in Solidity smart contracts where the return value of certain low-level functions, such as 'call', 'callcode', 'delegatecall', 'send', and 'staticcall', is not properly checked. These functions allow contracts to interact with other contracts, but if the return value is not adequately verified, it can lead to unexpected behaviors and potential vulnerabilities. When an unchecked call is made, the contract does not verify the success or failure of the called function. This can result in various issues, including reentrancy attacks, where an attacker exploits the unchecked call to recursively call back into the calling contract and manipulate its state. Additionally, if the return value is not validated, it could lead to erroneous assumptions about the execution status or data received, potentially causing critical security vulnerabilities.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract uncheckedCall inside the function uncheckedCall (Line: 306)</p><pre>    function sendToWinnerVuln() public {
        require(!payedOut);
        winner.send(winAmount);
        payedOut = true;
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Low-level call, unchecked return statement Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The unchecked call vulnerability refers to a security weakness in Solidity smart contracts where the return value of certain low-level functions, such as 'call', 'callcode', 'delegatecall', 'send', and 'staticcall', is not properly checked. These functions allow contracts to interact with other contracts, but if the return value is not adequately verified, it can lead to unexpected behaviors and potential vulnerabilities. When an unchecked call is made, the contract does not verify the success or failure of the called function. This can result in various issues, including reentrancy attacks, where an attacker exploits the unchecked call to recursively call back into the calling contract and manipulate its state. Additionally, if the return value is not validated, it could lead to erroneous assumptions about the execution status or data received, potentially causing critical security vulnerabilities.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract uncheckedCall inside the function uncheckedCall (Line: 311)</p><pre>    function callVuln() public {
        msg.sender.call{value: winAmount}("");
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Low-level call, unchecked return statement Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The unchecked call vulnerability refers to a security weakness in Solidity smart contracts where the return value of certain low-level functions, such as 'call', 'callcode', 'delegatecall', 'send', and 'staticcall', is not properly checked. These functions allow contracts to interact with other contracts, but if the return value is not adequately verified, it can lead to unexpected behaviors and potential vulnerabilities. When an unchecked call is made, the contract does not verify the success or failure of the called function. This can result in various issues, including reentrancy attacks, where an attacker exploits the unchecked call to recursively call back into the calling contract and manipulate its state. Additionally, if the return value is not validated, it could lead to erroneous assumptions about the execution status or data received, potentially causing critical security vulnerabilities.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract uncheckedCall inside the function uncheckedCall (Line: 446)</p><pre>    function refundAll() public {
        for(uint x; x < refundAddresses.length; x++) { // arbitrary length iteration based on how many addresses participated
            require(gasleft() > 1000);
            require(payable(refundAddresses[x]).send(refunds[refundAddresses[x]])); // doubly bad, now a single failure on send will hold up all funds
        }
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Low-level call, unchecked return statement Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The unchecked call vulnerability refers to a security weakness in Solidity smart contracts where the return value of certain low-level functions, such as 'call', 'callcode', 'delegatecall', 'send', and 'staticcall', is not properly checked. These functions allow contracts to interact with other contracts, but if the return value is not adequately verified, it can lead to unexpected behaviors and potential vulnerabilities. When an unchecked call is made, the contract does not verify the success or failure of the called function. This can result in various issues, including reentrancy attacks, where an attacker exploits the unchecked call to recursively call back into the calling contract and manipulate its state. Additionally, if the return value is not validated, it could lead to erroneous assumptions about the execution status or data received, potentially causing critical security vulnerabilities.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract uncheckedCall inside the function uncheckedCall (Line: 455)</p><pre>    function refundAllRequire() public {
        uint x = 0;
        while(refundAddresses.length > 5) { // arbitrary length iteration based on how many addresses participated
            require(gasleft() > 1000);
            require(payable(refundAddresses[x]).send(refunds[refundAddresses[x]])); // doubly bad, now a single failure on send will hold up all funds
            x++;
        }
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Low-level call, unchecked return statement Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The unchecked call vulnerability refers to a security weakness in Solidity smart contracts where the return value of certain low-level functions, such as 'call', 'callcode', 'delegatecall', 'send', and 'staticcall', is not properly checked. These functions allow contracts to interact with other contracts, but if the return value is not adequately verified, it can lead to unexpected behaviors and potential vulnerabilities. When an unchecked call is made, the contract does not verify the success or failure of the called function. This can result in various issues, including reentrancy attacks, where an attacker exploits the unchecked call to recursively call back into the calling contract and manipulate its state. Additionally, if the return value is not validated, it could lead to erroneous assumptions about the execution status or data received, potentially causing critical security vulnerabilities.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract uncheckedCall inside the function uncheckedCall (Line: 465)</p><pre>    function refundAll2() public {
        uint x = 0;
        require(gasleft() > 1000);
        while(refundAddresses.length > 5 && gasleft() > 1000) { // arbitrary length iteration based on how many addresses participated
            require(payable(refundAddresses[x]).send(refunds[refundAddresses[x]])); // doubly bad, now a single failure on send will hold up all funds
            x++;
        }
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Low-level call, unchecked return statement Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The unchecked call vulnerability refers to a security weakness in Solidity smart contracts where the return value of certain low-level functions, such as 'call', 'callcode', 'delegatecall', 'send', and 'staticcall', is not properly checked. These functions allow contracts to interact with other contracts, but if the return value is not adequately verified, it can lead to unexpected behaviors and potential vulnerabilities. When an unchecked call is made, the contract does not verify the success or failure of the called function. This can result in various issues, including reentrancy attacks, where an attacker exploits the unchecked call to recursively call back into the calling contract and manipulate its state. Additionally, if the return value is not validated, it could lead to erroneous assumptions about the execution status or data received, potentially causing critical security vulnerabilities.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract uncheckedCall inside the function uncheckedCall (Line: 482)</p><pre>    function refundAll() public {
        for(uint x; x < refundAddresses.length; x++) { // arbitrary length iteration based on how many addresses participated
            require(gasleft() > 1000);
            require(payable(refundAddresses[x]).send(refunds[refundAddresses[x]])); // doubly bad, now a single failure on send will hold up all funds
        }
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Low-level call, unchecked return statement Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The unchecked call vulnerability refers to a security weakness in Solidity smart contracts where the return value of certain low-level functions, such as 'call', 'callcode', 'delegatecall', 'send', and 'staticcall', is not properly checked. These functions allow contracts to interact with other contracts, but if the return value is not adequately verified, it can lead to unexpected behaviors and potential vulnerabilities. When an unchecked call is made, the contract does not verify the success or failure of the called function. This can result in various issues, including reentrancy attacks, where an attacker exploits the unchecked call to recursively call back into the calling contract and manipulate its state. Additionally, if the return value is not validated, it could lead to erroneous assumptions about the execution status or data received, potentially causing critical security vulnerabilities.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract uncheckedCall inside the function uncheckedCall (Line: 491)</p><pre>    function refundAllRequire() public {
        uint x = 0;
        while(refundAddresses.length > 5) { // arbitrary length iteration based on how many addresses participated
            require(gasleft() > 1000);
            require(payable(refundAddresses[x]).send(refunds[refundAddresses[x]])); // doubly bad, now a single failure on send will hold up all funds
            x++;
        }
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Low-level call, unchecked return statement Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The unchecked call vulnerability refers to a security weakness in Solidity smart contracts where the return value of certain low-level functions, such as 'call', 'callcode', 'delegatecall', 'send', and 'staticcall', is not properly checked. These functions allow contracts to interact with other contracts, but if the return value is not adequately verified, it can lead to unexpected behaviors and potential vulnerabilities. When an unchecked call is made, the contract does not verify the success or failure of the called function. This can result in various issues, including reentrancy attacks, where an attacker exploits the unchecked call to recursively call back into the calling contract and manipulate its state. Additionally, if the return value is not validated, it could lead to erroneous assumptions about the execution status or data received, potentially causing critical security vulnerabilities.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract uncheckedCall inside the function uncheckedCall (Line: 501)</p><pre>    function refundAll2() public {
        uint x = 0;
        require(gasleft() > 1000);
        while(refundAddresses.length > 5 && gasleft() > 1000) { // arbitrary length iteration based on how many addresses participated
            require(payable(refundAddresses[x]).send(refunds[refundAddresses[x]])); // doubly bad, now a single failure on send will hold up all funds
            x++;
        }
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>SelfDestruct Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>This vulnerability arises when the selfdestruct function is not properly handled. The selfdestruct function allows a contract to intentionally destroy itself and transfer any remaining funds to a designated address. However, if this function is not used carefully, it can lead to unintended consequences. The vulnerability occurs when the selfdestruct function is called without appropriate checks or validations. Malicious actors can exploit this vulnerability by deploying a malicious contract and tricking the targeted contract into executing selfdestruct. As a result, all the remaining funds in the targeted contract are transferred to the attacker's designated address, rendering them inaccessible to the contract owner and other legitimate users.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract selfdestruct inside the function selfdestruct (Line: 224)</p><pre>    function attack(address payable receiver) public payable {
        // You can simply break the game by sending ether so that
        // the game balance >= 7 ether

        // cast address to payable
        selfdestruct(receiver);
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Major Gap beetween pragma versions</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The pragma version gap vulnerability refers to a situation where there is a significant difference in the Solidity compiler version specified in the pragma directive and the actual compiler version used for compiling the smart contract. This discrepancy can lead to unexpected behavior, including potential vulnerabilities and compatibility issues. If there is a substantial gap between the versions specified, different compiler versions may introduce changes, bug fixes or security enhancements that affect the interpretation and execution of the contract, potentially leading to relying on outdated or incompatible features, exposing the contract to security vulnerabilities.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract pragmaVersion inside the function pragmaVersion (Line: 87)</p><pre>pragma solidity >=0.8.13 <=0.8.19;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Solidity version [Minor] outdated</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The minor version of the pragma directive in the Solidity smart contract specifies a minor compiler version that is outdated compared to the current compiler version. This can result in the contract relying on outdated and potentially insecure features, making it susceptible to known vulnerabilities or attacks that have been addressed in newer compiler versions.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract pragmaVersion inside the function pragmaVersion (Line: 334)</p><pre>pragma solidity > 0.7.1;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Integer Overflow & Underflow [Outdated Version]</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Integer overflow and underflow are vulnerabilities found in Solidity smart contracts in versions prior to 0.8.0. Integer overflow occurs when the value of an integer variable exceeds its maximum range, causing it to wrap around to the minimum value. On the other hand, integer underflow happens when the value goes below its minimum range, it causing it to wrap around to the maximum value. These vulnerabilities can lead to unexpected calculations and behaviors, potentially allowing malicious actors to manipulate the contract's state or control its execution flow.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract integer inside the function integer (Line: 334)</p><pre>pragma solidity > 0.7.1;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Integer Overflow & Underflow [Unchecked Modifier]</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Integer overflow and underflow happen when the unchecked modifier is used, it is advised to use the unchecked modifier carefully. When the unchecked modifier is used, arithmetic operations on integer variables are performed without boundary checks. This can lead to unexpected and potentially malicious behavior if the calculations exceed the maximum or minimum values of the integer type, causing values to wrap around to the opposite end. This vulnerability can result in incorrect calculations, unexpected behaviors, or even the loss of funds in financial contracts.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract integer inside the function integer (Line: 408)</p><pre>    function add(uint x, uint y) external pure returns (uint) {
        unchecked {
            return x + y;
        }
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Integer Overflow & Underflow [Unchecked Modifier]</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Integer overflow and underflow happen when the unchecked modifier is used, it is advised to use the unchecked modifier carefully. When the unchecked modifier is used, arithmetic operations on integer variables are performed without boundary checks. This can lead to unexpected and potentially malicious behavior if the calculations exceed the maximum or minimum values of the integer type, causing values to wrap around to the opposite end. This vulnerability can result in incorrect calculations, unexpected behaviors, or even the loss of funds in financial contracts.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract integer inside the function integer (Line: 414)</p><pre>    function sub(uint x, uint y) external pure returns (uint) {
        unchecked {
            return x - y;
        }
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Integer Overflow & Underflow [Unchecked Modifier]</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Integer overflow and underflow happen when the unchecked modifier is used, it is advised to use the unchecked modifier carefully. When the unchecked modifier is used, arithmetic operations on integer variables are performed without boundary checks. This can lead to unexpected and potentially malicious behavior if the calculations exceed the maximum or minimum values of the integer type, causing values to wrap around to the opposite end. This vulnerability can result in incorrect calculations, unexpected behaviors, or even the loss of funds in financial contracts.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract integer inside the function integer (Line: 420)</p><pre>    function sumOfCubes(uint x, uint y) external pure returns (uint) {
        unchecked {
            uint x3 = x * x * x;
            uint y3 = y * y * y;

            return x3 + y3;
        }
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Tx.origin vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>This vunerability happens when the tx.origin global variable is used for access control or authentication purposes. This variable provides the original external sender of the transaction, but relying on it for security checks can lead to exploitable vulnerabilities. The vulnerability occurs because tx.origin does not represent the direct caller of the contract's function. If there is a chain of contract calls or interactions, the tx.origin will always reflect the original external sender, even if an intermediate contract invoked the function. This can be manipulated by attackers who control intermediate contracts to impersonate the original sender.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract tx.origin inside the function tx.origin (Line: 281)</p><pre>    function doSomething(uint _num) public {
        lib.delegatecall(abi.encodeWithSignature("doSomething(uint256)", _num));
        address x = tx.origin;
        //function transfer
        payable(x).transfer(2);
        payable(x).send(2);

    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Tx.origin vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>This vunerability happens when the tx.origin global variable is used for access control or authentication purposes. This variable provides the original external sender of the transaction, but relying on it for security checks can lead to exploitable vulnerabilities. The vulnerability occurs because tx.origin does not represent the direct caller of the contract's function. If there is a chain of contract calls or interactions, the tx.origin will always reflect the original external sender, even if an intermediate contract invoked the function. This can be manipulated by attackers who control intermediate contracts to impersonate the original sender.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract tx.origin inside the function tx.origin (Line: 387)</p><pre>    function transfer(address payable _to, uint _amount) public {
        require(tx.origin == owner, "Not owner");

        (bool sent, ) = _to.call{value: _amount}("");
        require(sent, "Failed to send Ether");
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Possible Reentrancy vulnerability, modifier found</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Although a 'nonReentrant' modifier that could prevent a reentrancy vulnerability has been found, it is advisable to review the function and make sure it is truly securized. Make sure the implementation is ReentrancyGuard from OpenZeppelin</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract reentrancy inside the function reentrancy (Line: 80)</p><pre>function withdrawAll() payable nonReentrant public {

    uint256 balance = balances[msg.sender];
    require(balance > 0, "Insufficient balance");

    (bool success, ) = msg.sender.call{value: balance}("");
    require(success, "Failed to send Ether");

    balances[msg.sender] = 0;
}
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Possible selfdestruct vulnerability, require owner found</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Although a require could prevent calling 'selfdestruct' has been found, it is advisable to review the function and make sure it is securized. Make sure the 'selfdestruct' function can only be called by the owner (contract deployer).</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract selfdestruct inside the function selfdestruct (Line: 158)</p><pre>    function attack(address payable receiver) public payable {
        require(msg.sender == owner);
        // You can simply break the game by sending ether so that
        // the game balance >= 7 ether

        // cast address to payable
        selfdestruct(receiver);
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Possible selfdestruct vulnerability, OnlyOwner found</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Although a onlyOwner modifier that could prevent calling 'selfdestruct' has been found, it is advisable to review the function and make sure it is securized. Make sure the 'selfdestruct' function can only be called by the owner (contract deployer).</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract selfdestruct inside the function selfdestruct (Line: 166)</p><pre>    function attack2(address payable receiver) onlyOwner public payable {
        // You can simply break the game by sending ether so that
        // the game balance >= 7 ether

        // cast address to payable
        selfdestruct(receiver);
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Possible selfdestruct vulnerability, Private found</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Although a private modifier that could prevent calling 'selfdestruct' has been found, it is advisable to review the function and make sure it is securized. Make sure the 'selfdestruct' function can only be called by the owner (contract deployer).</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract selfdestruct inside the function selfdestruct (Line: 174)</p><pre>       function attack3(address payable receiver) private {
        // You can simply break the game by sending ether so that
        // the game balance >= 7 ether

        // cast address to payable
        selfdestruct(receiver);
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Block Timestamp Manipulation Vulnerability [block.timestamp]</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The block timestamp manipulation vulnerability refers to a security issue in Solidity smart contracts that arises when the block.timestamp variable is used for critical operations such as time-based access control or timestamp-based calculations. This value can be manipulated by miners, compromising the integrity and functionality of the contract. If it is being used for critical time operations, it is advisable to avoid relying solely on block.timestamp, but use alternatives as oracles for critical time-dependent operations.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract timestamp inside the function timestamp (Line: 361)</p><pre>    function spin() external payable {
        require(msg.value == 10 ether); // must send 10 ether to play
        require(block.number != pastBlockTime); // only 1 transaction per block

        pastBlockTime = block.timestamp;

        if (block.number % 15 == 0) {
            (bool sent, ) = msg.sender.call{value: address(this).balance}("");
            require(sent, "Failed to send Ether");
        }
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Delegatecall vulnerability</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Delegatecall is a low-level function that allows a contract to execute code from another contract while preserving the calling contract's storage and context. If an attacker can manipulate the delegatecall to execute malicious code, they may be able to manipulate the state of the calling contract or execute unauthorized operations. The attacker can potentially override important contract functions, bypass access controls, or even take control of the contract's execution flow. This can result in financial losses, unauthorized access, or other malicious activities.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract delegatecall inside the function delegatecall (Line: 257)</p><pre>    function withdraw() public payable{
        withdrawalCounter += 1;
        // this sets calculatedFibNumber
        fibonacciLibrary.delegatecall(abi.encode(fibSig, withdrawalCounter));
        payable(msg.sender).transfer(calculatedFibNumber * 1 ether);
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Save Gas: change 'transfer' for 'call'</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>When using 'transfer', a fixed amount of gas is allocated for the execution of the called contract. This function do not allow for specifying a custom amount of gas or handling the return value, limiting their flexibility. By changing the 'transfer' function by 'call', developers can optimize gas usage, handle exceptions, and react accordingly based on the return value.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract transfer inside the function transfer (Line: 258)</p><pre>    function withdraw() public payable{
        withdrawalCounter += 1;
        // this sets calculatedFibNumber
        fibonacciLibrary.delegatecall(abi.encode(fibSig, withdrawalCounter));
        payable(msg.sender).transfer(calculatedFibNumber * 1 ether);
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Delegatecall vulnerability</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Delegatecall is a low-level function that allows a contract to execute code from another contract while preserving the calling contract's storage and context. If an attacker can manipulate the delegatecall to execute malicious code, they may be able to manipulate the state of the calling contract or execute unauthorized operations. The attacker can potentially override important contract functions, bypass access controls, or even take control of the contract's execution flow. This can result in financial losses, unauthorized access, or other malicious activities.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract delegatecall inside the function delegatecall (Line: 263)</p><pre>    function pp() public {
        fibonacciLibrary.delegatecall(msg.data);
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Delegatecall vulnerability</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Delegatecall is a low-level function that allows a contract to execute code from another contract while preserving the calling contract's storage and context. If an attacker can manipulate the delegatecall to execute malicious code, they may be able to manipulate the state of the calling contract or execute unauthorized operations. The attacker can potentially override important contract functions, bypass access controls, or even take control of the contract's execution flow. This can result in financial losses, unauthorized access, or other malicious activities.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract delegatecall inside the function delegatecall (Line: 280)</p><pre>    function doSomething(uint _num) public {
        lib.delegatecall(abi.encodeWithSignature("doSomething(uint256)", _num));
        address x = tx.origin;
        //function transfer
        payable(x).transfer(2);
        payable(x).send(2);

    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Save Gas: change 'transfer' for 'call'</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>When using 'transfer', a fixed amount of gas is allocated for the execution of the called contract. This function do not allow for specifying a custom amount of gas or handling the return value, limiting their flexibility. By changing the 'transfer' function by 'call', developers can optimize gas usage, handle exceptions, and react accordingly based on the return value.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract transfer inside the function transfer (Line: 283)</p><pre>    function doSomething(uint _num) public {
        lib.delegatecall(abi.encodeWithSignature("doSomething(uint256)", _num));
        address x = tx.origin;
        //function transfer
        payable(x).transfer(2);
        payable(x).send(2);

    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Save Gas: change 'send' for 'call'</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>When using 'send', a fixed amount of gas is allocated for the execution of the called contract. This function do not allow for specifying a custom amount of gas or handling the return value, limiting their flexibility. By changing the 'send' function by 'call', developers can optimize gas usage, handle exceptions, and react accordingly based on the return value.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract send inside the function send (Line: 284)</p><pre>    function doSomething(uint _num) public {
        lib.delegatecall(abi.encodeWithSignature("doSomething(uint256)", _num));
        address x = tx.origin;
        //function transfer
        payable(x).transfer(2);
        payable(x).send(2);

    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Save Gas: change 'send' for 'call'</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>When using 'send', a fixed amount of gas is allocated for the execution of the called contract. This function do not allow for specifying a custom amount of gas or handling the return value, limiting their flexibility. By changing the 'send' function by 'call', developers can optimize gas usage, handle exceptions, and react accordingly based on the return value.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract send inside the function send (Line: 306)</p><pre>    function sendToWinnerVuln() public {
        require(!payedOut);
        winner.send(winAmount);
        payedOut = true;
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Save Gas: change 'send' for 'call'</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>When using 'send', a fixed amount of gas is allocated for the execution of the called contract. This function do not allow for specifying a custom amount of gas or handling the return value, limiting their flexibility. By changing the 'send' function by 'call', developers can optimize gas usage, handle exceptions, and react accordingly based on the return value.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract send inside the function send (Line: 316)</p><pre>    function sendToWinner() public {
        require(!payedOut);
        (bool success) = winner.send(winAmount);
        payedOut = true;
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Save Gas: change 'send' for 'call'</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>When using 'send', a fixed amount of gas is allocated for the execution of the called contract. This function do not allow for specifying a custom amount of gas or handling the return value, limiting their flexibility. By changing the 'send' function by 'call', developers can optimize gas usage, handle exceptions, and react accordingly based on the return value.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract send inside the function send (Line: 446)</p><pre>    function refundAll() public {
        for(uint x; x < refundAddresses.length; x++) { // arbitrary length iteration based on how many addresses participated
            require(gasleft() > 1000);
            require(payable(refundAddresses[x]).send(refunds[refundAddresses[x]])); // doubly bad, now a single failure on send will hold up all funds
        }
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Save Gas: change 'send' for 'call'</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>When using 'send', a fixed amount of gas is allocated for the execution of the called contract. This function do not allow for specifying a custom amount of gas or handling the return value, limiting their flexibility. By changing the 'send' function by 'call', developers can optimize gas usage, handle exceptions, and react accordingly based on the return value.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract send inside the function send (Line: 455)</p><pre>    function refundAllRequire() public {
        uint x = 0;
        while(refundAddresses.length > 5) { // arbitrary length iteration based on how many addresses participated
            require(gasleft() > 1000);
            require(payable(refundAddresses[x]).send(refunds[refundAddresses[x]])); // doubly bad, now a single failure on send will hold up all funds
            x++;
        }
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Save Gas: change 'send' for 'call'</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>When using 'send', a fixed amount of gas is allocated for the execution of the called contract. This function do not allow for specifying a custom amount of gas or handling the return value, limiting their flexibility. By changing the 'send' function by 'call', developers can optimize gas usage, handle exceptions, and react accordingly based on the return value.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract send inside the function send (Line: 465)</p><pre>    function refundAll2() public {
        uint x = 0;
        require(gasleft() > 1000);
        while(refundAddresses.length > 5 && gasleft() > 1000) { // arbitrary length iteration based on how many addresses participated
            require(payable(refundAddresses[x]).send(refunds[refundAddresses[x]])); // doubly bad, now a single failure on send will hold up all funds
            x++;
        }
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Save Gas: change 'send' for 'call'</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>When using 'send', a fixed amount of gas is allocated for the execution of the called contract. This function do not allow for specifying a custom amount of gas or handling the return value, limiting their flexibility. By changing the 'send' function by 'call', developers can optimize gas usage, handle exceptions, and react accordingly based on the return value.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract send inside the function send (Line: 482)</p><pre>    function refundAll() public {
        for(uint x; x < refundAddresses.length; x++) { // arbitrary length iteration based on how many addresses participated
            require(gasleft() > 1000);
            require(payable(refundAddresses[x]).send(refunds[refundAddresses[x]])); // doubly bad, now a single failure on send will hold up all funds
        }
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Save Gas: change 'send' for 'call'</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>When using 'send', a fixed amount of gas is allocated for the execution of the called contract. This function do not allow for specifying a custom amount of gas or handling the return value, limiting their flexibility. By changing the 'send' function by 'call', developers can optimize gas usage, handle exceptions, and react accordingly based on the return value.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract send inside the function send (Line: 491)</p><pre>    function refundAllRequire() public {
        uint x = 0;
        while(refundAddresses.length > 5) { // arbitrary length iteration based on how many addresses participated
            require(gasleft() > 1000);
            require(payable(refundAddresses[x]).send(refunds[refundAddresses[x]])); // doubly bad, now a single failure on send will hold up all funds
            x++;
        }
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Save Gas: change 'send' for 'call'</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>When using 'send', a fixed amount of gas is allocated for the execution of the called contract. This function do not allow for specifying a custom amount of gas or handling the return value, limiting their flexibility. By changing the 'send' function by 'call', developers can optimize gas usage, handle exceptions, and react accordingly based on the return value.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract send inside the function send (Line: 501)</p><pre>    function refundAll2() public {
        uint x = 0;
        require(gasleft() > 1000);
        while(refundAddresses.length > 5 && gasleft() > 1000) { // arbitrary length iteration based on how many addresses participated
            require(payable(refundAddresses[x]).send(refunds[refundAddresses[x]])); // doubly bad, now a single failure on send will hold up all funds
            x++;
        }
    }
</pre></div>
        </div>
    
        </div>
        
        <div class="container" id="requires">
            <h2>Requires</h2>
            <div class="info-row">
                <h4>The following requires have been found several times. It is advisabe to replace them with a modifier</h4>
            </div>
        <div class="requires-grid">
    
                <div class="require_card">
                    <p> The following require appears 3 times in the contract at lines [21, 78, 97]
                    </p><pre>require(balance > 0, "Insufficient balance");</pre>
                    <p> Please consider using the following modifier. It will save gas and make your code more efficient. </p> 
                    <pre class="modifier">modifier << NAME_OF_YOUR_MODIFIER >> () { 
    require(balance > 0, "Insufficient balance");
    _; 
 } </pre>
                </div>
                <div class="require_card">
                    <p> The following require appears 3 times in the contract at lines [24, 81, 100]
                    </p><pre>require(success, "Failed to send Ether");</pre>
                    <p> Please consider using the following modifier. It will save gas and make your code more efficient. </p> 
                    <pre class="modifier">modifier << NAME_OF_YOUR_MODIFIER >> () { 
    require(success, "Failed to send Ether");
    _; 
 } </pre>
                </div>
                <div class="require_card">
                    <p> The following require appears 4 times in the contract at lines [149, 216, 365, 390]
                    </p><pre>require(sent, "Failed to send Ether");</pre>
                    <p> Please consider using the following modifier. It will save gas and make your code more efficient. </p> 
                    <pre class="modifier">modifier << NAME_OF_YOUR_MODIFIER >> () { 
    require(sent, "Failed to send Ether");
    _; 
 } </pre>
                </div>
                <div class="require_card">
                    <p> The following require appears 6 times in the contract at lines [445, 454, 463, 481, 490, 499]
                    </p><pre>require(gasleft() > 1000);</pre>
                    <p> Please consider using the following modifier. It will save gas and make your code more efficient. </p> 
                    <pre class="modifier">modifier << NAME_OF_YOUR_MODIFIER >> () { 
    require(gasleft() > 1000);
    _; 
 } </pre>
                </div>
                <div class="require_card">
                    <p> The following require appears 6 times in the contract at lines [446, 455, 465, 482, 491, 501]
                    </p><pre>require(payable(refundAddresses[x]).send(refunds[refundAddresses[x]])); </pre>
                    <p> Please consider using the following modifier. It will save gas and make your code more efficient. </p> 
                    <pre class="modifier">modifier << NAME_OF_YOUR_MODIFIER >> () { 
    require(payable(refundAddresses[x]).send(refunds[refundAddresses[x]])); 
    _; 
 } </pre>
                </div>
            </div>
        </div>
    
        </body>
        </html>
    