
        <!DOCTYPE html>
        <html>
        <head>
        <link rel="stylesheet" href="utils/style.css">
        <title>Report</title>
        </head>
        <body>
    
        <div class="pageHeader">
            <div class="iconName"> <img src="icon.png" alt="Logo" width="40" height="40"> Solidity Guard </div>
            <div class="separator"> </div>
            <a href="#dashboard"> Dashboard </a>
            <a href="#findings"> Findings </a>
            <a href="#requires"> Requires </a>
        </div>
        
        <div class="container">
        <h1>Report</h1>
        <div class="SGuardHeader">
            <div class='Text'>
                <p>This is an automated report created with the tool <b>Solidity Guard</b>. This tool searches for vulnerabilities in the source code of Solidity Smart contracts with static analysis by traversing its Abstract Syntax Tree (AST). There are several detectors developed, that can find:
                <u>Reentrancy</u> vulnerabilities, unchecked low level calls, <u>selfdestructs</u> not protected, <u>tx.origin</u> usage, possible <u>overflows & underflows</u> vulnerabilities and <u>timestamps</u> calls. 
                Some advices to the developer are given as well, as reminders to review the integrity and correctness of <u>delegatecall</u>, and possible <u>denial of services</u> findings, due to for and while loops.
                Another functionality created is a <u>require checker</u>, that will recommend the use of a modifier when a require is found 3 or more times. 
                The findings will be shown in the next dashboard. </p>   
            </div>
            <div class='logo'>
                <img src="icon.png" alt="Logo" width="100" height="100">
                <div class='Links'>
                    <a href="github.com/ferrabled/SolidiyGuard">Github</a>
                    <a href="mailto:ferrabled@gmail.com">Contact</a>
                </div>
            </div>
        </div>
        </div>
    
        <div class="container" id="dashboard">
            <h2>Dashboard</h2>
            <div class="dash-row">
            <div class="analyzed">
                <div class="dcard">
                    <h3>Lines of code</h3>
                    <h2>486</h2>
                </div>
                <div class="dcard">
                    <h3>Contracts</h3>
                    <h2>16</h2>
                </div>
                <div class="dcard">
                    <h3>Functions</h3>
                    <h2>38</h2>
                </div>
            </div>
            <div class="findings">
                <div class="dcard">
                    <h3>Emits</h3>
                    <h2>0</h2>
                </div>
                <div class="dcard">
                    <h3>Requires</h3>
                    <h2>22</h2>
                </div>
                <div class="dcard">
                    <h3>Repeated Requires</h3>
                    <h2>0</h2>
                </div>
            </div>
            <div class="findings">
                <div class="dcard">
                    <h3>Findings</h3>
                    <h2>49</h2>
                </div>
                <div class="dcard">
                    <h3>Vulns.</h3>
                    <h2>37</h2>
                </div>
                <div class="dcard">
                    <h3>Warnings</h3>
                    <h2>12</h2>
                </div>
            </div>
            </div>
        </div>
    
    
        <div class="container" id="findings">
            <h2>Findings</h2> 
    
                <div class="finding">
                    <div class="title">
                        <h2>Reentrancy Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Reentrancy vulnerability is a security flaw found in Solidity smart contracts where a contract can be repeatedly called before the previous call has completed, potentially allowing malicious actors to manipulate the contract's state or control its execution flow. This vulnerability arises when a contract interacts with external contracts and fails to properly manage the order of execution and state changes. By exploiting reentrancy, an attacker can repeatedly call a contract's function and invoke their own malicious callback, potentially draining funds or causing undesired effects in the contract's logic. Proper handling of external calls and state management is crucial.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract reentrancy inside the function reentrancy (Line: 72)</p><pre>    function withdrawFunds (uint256 _weiToWithdraw) public {
        require(balances[msg.sender] >= _weiToWithdraw);
        // limit the withdrawal
        require(_weiToWithdraw <= withdrawalLimit);
        // limit the time allowed to withdraw
        require(now >= lastWithdrawTime[msg.sender] + 1 weeks);
        require(msg.sender.call.value(_weiToWithdraw)());
        balances[msg.sender] -= _weiToWithdraw;
        lastWithdrawTime[msg.sender] = now;
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Reentrancy Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Reentrancy vulnerability is a security flaw found in Solidity smart contracts where a contract can be repeatedly called before the previous call has completed, potentially allowing malicious actors to manipulate the contract's state or control its execution flow. This vulnerability arises when a contract interacts with external contracts and fails to properly manage the order of execution and state changes. By exploiting reentrancy, an attacker can repeatedly call a contract's function and invoke their own malicious callback, potentially draining funds or causing undesired effects in the contract's logic. Proper handling of external calls and state management is crucial.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract reentrancy inside the function reentrancy (Line: 236)</p><pre>    function CashOut(uint _am)
    {
        if(_am<=balances[msg.sender])
        {
            if(msg.sender.call.value(_am)())
            {
                balances[msg.sender]-=_am;
                TransferLog.AddMessage(msg.sender,_am,"CashOut");
            }
        }
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Low-level call, unchecked return statement Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The unchecked call vulnerability refers to a security weakness in Solidity smart contracts where the return value of certain low-level functions, such as 'call', 'callcode', 'delegatecall', 'send', and 'staticcall', is not properly checked. These functions allow contracts to interact with other contracts, but if the return value is not adequately verified, it can lead to unexpected behaviors and potential vulnerabilities. When an unchecked call is made, the contract does not verify the success or failure of the called function. This can result in various issues, including reentrancy attacks, where an attacker exploits the unchecked call to recursively call back into the calling contract and manipulate its state. Additionally, if the return value is not validated, it could lead to erroneous assumptions about the execution status or data received, potentially causing critical security vulnerabilities.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract uncheckedCall inside the function uncheckedCall (Line: 72)</p><pre>    function withdrawFunds (uint256 _weiToWithdraw) public {
        require(balances[msg.sender] >= _weiToWithdraw);
        // limit the withdrawal
        require(_weiToWithdraw <= withdrawalLimit);
        // limit the time allowed to withdraw
        require(now >= lastWithdrawTime[msg.sender] + 1 weeks);
        require(msg.sender.call.value(_weiToWithdraw)());
        balances[msg.sender] -= _weiToWithdraw;
        lastWithdrawTime[msg.sender] = now;
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Low-level call, unchecked return statement Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The unchecked call vulnerability refers to a security weakness in Solidity smart contracts where the return value of certain low-level functions, such as 'call', 'callcode', 'delegatecall', 'send', and 'staticcall', is not properly checked. These functions allow contracts to interact with other contracts, but if the return value is not adequately verified, it can lead to unexpected behaviors and potential vulnerabilities. When an unchecked call is made, the contract does not verify the success or failure of the called function. This can result in various issues, including reentrancy attacks, where an attacker exploits the unchecked call to recursively call back into the calling contract and manipulate its state. Additionally, if the return value is not validated, it could lead to erroneous assumptions about the execution status or data received, potentially causing critical security vulnerabilities.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract uncheckedCall inside the function uncheckedCall (Line: 142)</p><pre>    function withdraw() {
        withdrawalCounter += 1;
        // calculate the fibonacci number for the current withdrawal user
        // this sets calculatedFibNumber
        require(fibonacciLibrary.delegatecall(fibSig, withdrawalCounter));
        msg.sender.transfer(calculatedFibNumber * 1 ether);
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Low-level call, unchecked return statement Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The unchecked call vulnerability refers to a security weakness in Solidity smart contracts where the return value of certain low-level functions, such as 'call', 'callcode', 'delegatecall', 'send', and 'staticcall', is not properly checked. These functions allow contracts to interact with other contracts, but if the return value is not adequately verified, it can lead to unexpected behaviors and potential vulnerabilities. When an unchecked call is made, the contract does not verify the success or failure of the called function. This can result in various issues, including reentrancy attacks, where an attacker exploits the unchecked call to recursively call back into the calling contract and manipulate its state. Additionally, if the return value is not validated, it could lead to erroneous assumptions about the execution status or data received, potentially causing critical security vulnerabilities.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract uncheckedCall inside the function uncheckedCall (Line: 148)</p><pre>    function() public {
        require(fibonacciLibrary.delegatecall(msg.data));
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Low-level call, unchecked return statement Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The unchecked call vulnerability refers to a security weakness in Solidity smart contracts where the return value of certain low-level functions, such as 'call', 'callcode', 'delegatecall', 'send', and 'staticcall', is not properly checked. These functions allow contracts to interact with other contracts, but if the return value is not adequately verified, it can lead to unexpected behaviors and potential vulnerabilities. When an unchecked call is made, the contract does not verify the success or failure of the called function. This can result in various issues, including reentrancy attacks, where an attacker exploits the unchecked call to recursively call back into the calling contract and manipulate its state. Additionally, if the return value is not validated, it could lead to erroneous assumptions about the execution status or data received, potentially causing critical security vulnerabilities.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract uncheckedCall inside the function uncheckedCall (Line: 236)</p><pre>    function CashOut(uint _am)
    {
        if(_am<=balances[msg.sender])
        {
            if(msg.sender.call.value(_am)())
            {
                balances[msg.sender]-=_am;
                TransferLog.AddMessage(msg.sender,_am,"CashOut");
            }
        }
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Low-level call, unchecked return statement Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The unchecked call vulnerability refers to a security weakness in Solidity smart contracts where the return value of certain low-level functions, such as 'call', 'callcode', 'delegatecall', 'send', and 'staticcall', is not properly checked. These functions allow contracts to interact with other contracts, but if the return value is not adequately verified, it can lead to unexpected behaviors and potential vulnerabilities. When an unchecked call is made, the contract does not verify the success or failure of the called function. This can result in various issues, including reentrancy attacks, where an attacker exploits the unchecked call to recursively call back into the calling contract and manipulate its state. Additionally, if the return value is not validated, it could lead to erroneous assumptions about the execution status or data received, potentially causing critical security vulnerabilities.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract uncheckedCall inside the function uncheckedCall (Line: 324)</p><pre>    function sendToWinner() public {
        require(!payedOut);
        winner.send(winAmount);
        payedOut = true;
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Low-level call, unchecked return statement Vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The unchecked call vulnerability refers to a security weakness in Solidity smart contracts where the return value of certain low-level functions, such as 'call', 'callcode', 'delegatecall', 'send', and 'staticcall', is not properly checked. These functions allow contracts to interact with other contracts, but if the return value is not adequately verified, it can lead to unexpected behaviors and potential vulnerabilities. When an unchecked call is made, the contract does not verify the success or failure of the called function. This can result in various issues, including reentrancy attacks, where an attacker exploits the unchecked call to recursively call back into the calling contract and manipulate its state. Additionally, if the return value is not validated, it could lead to erroneous assumptions about the execution status or data received, potentially causing critical security vulnerabilities.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract uncheckedCall inside the function uncheckedCall (Line: 330)</p><pre>    function withdrawLeftOver() public {
        require(payedOut);
        msg.sender.send(this.balance);
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Solidity version [Minor] outdated</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The minor version of the pragma directive in the Solidity smart contract specifies a minor compiler version that is outdated compared to the current compiler version. This can result in the contract relying on outdated and potentially insecure features, making it susceptible to known vulnerabilities or attacks that have been addressed in newer compiler versions.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract pragmaVersion inside the function pragmaVersion (Line: 8)</p><pre>pragma solidity ^0.4.19;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Solidity version [Minor] outdated</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The minor version of the pragma directive in the Solidity smart contract specifies a minor compiler version that is outdated compared to the current compiler version. This can result in the contract relying on outdated and potentially insecure features, making it susceptible to known vulnerabilities or attacks that have been addressed in newer compiler versions.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract pragmaVersion inside the function pragmaVersion (Line: 56)</p><pre>pragma solidity ^0.4.19;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Solidity version [Minor] outdated</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The minor version of the pragma directive in the Solidity smart contract specifies a minor compiler version that is outdated compared to the current compiler version. This can result in the contract relying on outdated and potentially insecure features, making it susceptible to known vulnerabilities or attacks that have been addressed in newer compiler versions.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract pragmaVersion inside the function pragmaVersion (Line: 85)</p><pre>pragma solidity ^0.4.19;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Solidity version [Minor] outdated</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The minor version of the pragma directive in the Solidity smart contract specifies a minor compiler version that is outdated compared to the current compiler version. This can result in the contract relying on outdated and potentially insecure features, making it susceptible to known vulnerabilities or attacks that have been addressed in newer compiler versions.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract pragmaVersion inside the function pragmaVersion (Line: 123)</p><pre>pragma solidity ^0.4.19;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Solidity version [Minor] outdated</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The minor version of the pragma directive in the Solidity smart contract specifies a minor compiler version that is outdated compared to the current compiler version. This can result in the contract relying on outdated and potentially insecure features, making it susceptible to known vulnerabilities or attacks that have been addressed in newer compiler versions.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract pragmaVersion inside the function pragmaVersion (Line: 159)</p><pre>pragma solidity ^0.4.19;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Solidity version [Minor] outdated</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The minor version of the pragma directive in the Solidity smart contract specifies a minor compiler version that is outdated compared to the current compiler version. This can result in the contract relying on outdated and potentially insecure features, making it susceptible to known vulnerabilities or attacks that have been addressed in newer compiler versions.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract pragmaVersion inside the function pragmaVersion (Line: 185)</p><pre>pragma solidity ^0.4.19;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Solidity version [Minor] outdated</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The minor version of the pragma directive in the Solidity smart contract specifies a minor compiler version that is outdated compared to the current compiler version. This can result in the contract relying on outdated and potentially insecure features, making it susceptible to known vulnerabilities or attacks that have been addressed in newer compiler versions.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract pragmaVersion inside the function pragmaVersion (Line: 208)</p><pre>pragma solidity ^0.4.19;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Solidity version [Minor] outdated</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The minor version of the pragma directive in the Solidity smart contract specifies a minor compiler version that is outdated compared to the current compiler version. This can result in the contract relying on outdated and potentially insecure features, making it susceptible to known vulnerabilities or attacks that have been addressed in newer compiler versions.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract pragmaVersion inside the function pragmaVersion (Line: 277)</p><pre>pragma solidity ^0.4.19;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Solidity version [Minor] outdated</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The minor version of the pragma directive in the Solidity smart contract specifies a minor compiler version that is outdated compared to the current compiler version. This can result in the contract relying on outdated and potentially insecure features, making it susceptible to known vulnerabilities or attacks that have been addressed in newer compiler versions.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract pragmaVersion inside the function pragmaVersion (Line: 314)</p><pre>pragma solidity ^0.4.19;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Solidity version [Minor] outdated</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The minor version of the pragma directive in the Solidity smart contract specifies a minor compiler version that is outdated compared to the current compiler version. This can result in the contract relying on outdated and potentially insecure features, making it susceptible to known vulnerabilities or attacks that have been addressed in newer compiler versions.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract pragmaVersion inside the function pragmaVersion (Line: 343)</p><pre>pragma solidity ^0.4.19;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Solidity version [Minor] outdated</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The minor version of the pragma directive in the Solidity smart contract specifies a minor compiler version that is outdated compared to the current compiler version. This can result in the contract relying on outdated and potentially insecure features, making it susceptible to known vulnerabilities or attacks that have been addressed in newer compiler versions.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract pragmaVersion inside the function pragmaVersion (Line: 375)</p><pre>pragma solidity ^0.4.19;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Solidity version [Minor] outdated</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The minor version of the pragma directive in the Solidity smart contract specifies a minor compiler version that is outdated compared to the current compiler version. This can result in the contract relying on outdated and potentially insecure features, making it susceptible to known vulnerabilities or attacks that have been addressed in newer compiler versions.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract pragmaVersion inside the function pragmaVersion (Line: 413)</p><pre>pragma solidity ^0.4.19;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Solidity version [Minor] outdated</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The minor version of the pragma directive in the Solidity smart contract specifies a minor compiler version that is outdated compared to the current compiler version. This can result in the contract relying on outdated and potentially insecure features, making it susceptible to known vulnerabilities or attacks that have been addressed in newer compiler versions.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract pragmaVersion inside the function pragmaVersion (Line: 436)</p><pre>pragma solidity ^0.4.19;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Solidity version [Minor] outdated</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>The minor version of the pragma directive in the Solidity smart contract specifies a minor compiler version that is outdated compared to the current compiler version. This can result in the contract relying on outdated and potentially insecure features, making it susceptible to known vulnerabilities or attacks that have been addressed in newer compiler versions.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract pragmaVersion inside the function pragmaVersion (Line: 469)</p><pre>pragma solidity ^0.4.18;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Integer Overflow & Underflow [Outdated Version]</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Integer overflow and underflow are vulnerabilities found in Solidity smart contracts in versions prior to 0.8.0. Integer overflow occurs when the value of an integer variable exceeds its maximum range, causing it to wrap around to the minimum value. On the other hand, integer underflow happens when the value goes below its minimum range, it causing it to wrap around to the maximum value. These vulnerabilities can lead to unexpected calculations and behaviors, potentially allowing malicious actors to manipulate the contract's state or control its execution flow.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract integer inside the function integer (Line: 8)</p><pre>pragma solidity ^0.4.19;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Integer Overflow & Underflow [Outdated Version]</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Integer overflow and underflow are vulnerabilities found in Solidity smart contracts in versions prior to 0.8.0. Integer overflow occurs when the value of an integer variable exceeds its maximum range, causing it to wrap around to the minimum value. On the other hand, integer underflow happens when the value goes below its minimum range, it causing it to wrap around to the maximum value. These vulnerabilities can lead to unexpected calculations and behaviors, potentially allowing malicious actors to manipulate the contract's state or control its execution flow.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract integer inside the function integer (Line: 56)</p><pre>pragma solidity ^0.4.19;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Integer Overflow & Underflow [Outdated Version]</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Integer overflow and underflow are vulnerabilities found in Solidity smart contracts in versions prior to 0.8.0. Integer overflow occurs when the value of an integer variable exceeds its maximum range, causing it to wrap around to the minimum value. On the other hand, integer underflow happens when the value goes below its minimum range, it causing it to wrap around to the maximum value. These vulnerabilities can lead to unexpected calculations and behaviors, potentially allowing malicious actors to manipulate the contract's state or control its execution flow.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract integer inside the function integer (Line: 85)</p><pre>pragma solidity ^0.4.19;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Integer Overflow & Underflow [Outdated Version]</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Integer overflow and underflow are vulnerabilities found in Solidity smart contracts in versions prior to 0.8.0. Integer overflow occurs when the value of an integer variable exceeds its maximum range, causing it to wrap around to the minimum value. On the other hand, integer underflow happens when the value goes below its minimum range, it causing it to wrap around to the maximum value. These vulnerabilities can lead to unexpected calculations and behaviors, potentially allowing malicious actors to manipulate the contract's state or control its execution flow.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract integer inside the function integer (Line: 123)</p><pre>pragma solidity ^0.4.19;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Integer Overflow & Underflow [Outdated Version]</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Integer overflow and underflow are vulnerabilities found in Solidity smart contracts in versions prior to 0.8.0. Integer overflow occurs when the value of an integer variable exceeds its maximum range, causing it to wrap around to the minimum value. On the other hand, integer underflow happens when the value goes below its minimum range, it causing it to wrap around to the maximum value. These vulnerabilities can lead to unexpected calculations and behaviors, potentially allowing malicious actors to manipulate the contract's state or control its execution flow.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract integer inside the function integer (Line: 159)</p><pre>pragma solidity ^0.4.19;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Integer Overflow & Underflow [Outdated Version]</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Integer overflow and underflow are vulnerabilities found in Solidity smart contracts in versions prior to 0.8.0. Integer overflow occurs when the value of an integer variable exceeds its maximum range, causing it to wrap around to the minimum value. On the other hand, integer underflow happens when the value goes below its minimum range, it causing it to wrap around to the maximum value. These vulnerabilities can lead to unexpected calculations and behaviors, potentially allowing malicious actors to manipulate the contract's state or control its execution flow.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract integer inside the function integer (Line: 185)</p><pre>pragma solidity ^0.4.19;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Integer Overflow & Underflow [Outdated Version]</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Integer overflow and underflow are vulnerabilities found in Solidity smart contracts in versions prior to 0.8.0. Integer overflow occurs when the value of an integer variable exceeds its maximum range, causing it to wrap around to the minimum value. On the other hand, integer underflow happens when the value goes below its minimum range, it causing it to wrap around to the maximum value. These vulnerabilities can lead to unexpected calculations and behaviors, potentially allowing malicious actors to manipulate the contract's state or control its execution flow.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract integer inside the function integer (Line: 208)</p><pre>pragma solidity ^0.4.19;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Integer Overflow & Underflow [Outdated Version]</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Integer overflow and underflow are vulnerabilities found in Solidity smart contracts in versions prior to 0.8.0. Integer overflow occurs when the value of an integer variable exceeds its maximum range, causing it to wrap around to the minimum value. On the other hand, integer underflow happens when the value goes below its minimum range, it causing it to wrap around to the maximum value. These vulnerabilities can lead to unexpected calculations and behaviors, potentially allowing malicious actors to manipulate the contract's state or control its execution flow.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract integer inside the function integer (Line: 277)</p><pre>pragma solidity ^0.4.19;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Integer Overflow & Underflow [Outdated Version]</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Integer overflow and underflow are vulnerabilities found in Solidity smart contracts in versions prior to 0.8.0. Integer overflow occurs when the value of an integer variable exceeds its maximum range, causing it to wrap around to the minimum value. On the other hand, integer underflow happens when the value goes below its minimum range, it causing it to wrap around to the maximum value. These vulnerabilities can lead to unexpected calculations and behaviors, potentially allowing malicious actors to manipulate the contract's state or control its execution flow.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract integer inside the function integer (Line: 314)</p><pre>pragma solidity ^0.4.19;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Integer Overflow & Underflow [Outdated Version]</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Integer overflow and underflow are vulnerabilities found in Solidity smart contracts in versions prior to 0.8.0. Integer overflow occurs when the value of an integer variable exceeds its maximum range, causing it to wrap around to the minimum value. On the other hand, integer underflow happens when the value goes below its minimum range, it causing it to wrap around to the maximum value. These vulnerabilities can lead to unexpected calculations and behaviors, potentially allowing malicious actors to manipulate the contract's state or control its execution flow.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract integer inside the function integer (Line: 343)</p><pre>pragma solidity ^0.4.19;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Integer Overflow & Underflow [Outdated Version]</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Integer overflow and underflow are vulnerabilities found in Solidity smart contracts in versions prior to 0.8.0. Integer overflow occurs when the value of an integer variable exceeds its maximum range, causing it to wrap around to the minimum value. On the other hand, integer underflow happens when the value goes below its minimum range, it causing it to wrap around to the maximum value. These vulnerabilities can lead to unexpected calculations and behaviors, potentially allowing malicious actors to manipulate the contract's state or control its execution flow.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract integer inside the function integer (Line: 375)</p><pre>pragma solidity ^0.4.19;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Integer Overflow & Underflow [Outdated Version]</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Integer overflow and underflow are vulnerabilities found in Solidity smart contracts in versions prior to 0.8.0. Integer overflow occurs when the value of an integer variable exceeds its maximum range, causing it to wrap around to the minimum value. On the other hand, integer underflow happens when the value goes below its minimum range, it causing it to wrap around to the maximum value. These vulnerabilities can lead to unexpected calculations and behaviors, potentially allowing malicious actors to manipulate the contract's state or control its execution flow.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract integer inside the function integer (Line: 413)</p><pre>pragma solidity ^0.4.19;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Integer Overflow & Underflow [Outdated Version]</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Integer overflow and underflow are vulnerabilities found in Solidity smart contracts in versions prior to 0.8.0. Integer overflow occurs when the value of an integer variable exceeds its maximum range, causing it to wrap around to the minimum value. On the other hand, integer underflow happens when the value goes below its minimum range, it causing it to wrap around to the maximum value. These vulnerabilities can lead to unexpected calculations and behaviors, potentially allowing malicious actors to manipulate the contract's state or control its execution flow.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract integer inside the function integer (Line: 436)</p><pre>pragma solidity ^0.4.19;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Integer Overflow & Underflow [Outdated Version]</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Integer overflow and underflow are vulnerabilities found in Solidity smart contracts in versions prior to 0.8.0. Integer overflow occurs when the value of an integer variable exceeds its maximum range, causing it to wrap around to the minimum value. On the other hand, integer underflow happens when the value goes below its minimum range, it causing it to wrap around to the maximum value. These vulnerabilities can lead to unexpected calculations and behaviors, potentially allowing malicious actors to manipulate the contract's state or control its execution flow.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract integer inside the function integer (Line: 469)</p><pre>pragma solidity ^0.4.18;
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Tx.origin vulnerability</h2>
                        <div class="vuln"><b>Vulnerability</b></div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>This vunerability happens when the tx.origin global variable is used for access control or authentication purposes. This variable provides the original external sender of the transaction, but relying on it for security checks can lead to exploitable vulnerabilities. The vulnerability occurs because tx.origin does not represent the direct caller of the contract's function. If there is a chain of contract calls or interactions, the tx.origin will always reflect the original external sender, even if an intermediate contract invoked the function. This can be manipulated by attackers who control intermediate contracts to impersonate the original sender.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract tx.origin inside the function tx.origin (Line: 424)</p><pre>    function withdrawAll(address _recipient) public {
        require(tx.origin == owner);
        _recipient.transfer(this.balance); 
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Save Gas: change 'transfer' for 'call'</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>When using 'transfer', a fixed amount of gas is allocated for the execution of the called contract. This function do not allow for specifying a custom amount of gas or handling the return value, limiting their flexibility. By changing the 'transfer' function by 'call', developers can optimize gas usage, handle exceptions, and react accordingly based on the return value.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract transfer inside the function transfer (Line: 44)</p><pre>    function claimReward() public {
        // ensure the game is complete
        require(this.balance == finalMileStone);
        // ensure there is a reward to give
        require(redeemableEther[msg.sender] > 0); 
        redeemableEther[msg.sender] = 0;
        msg.sender.transfer(redeemableEther[msg.sender]);
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Save Gas: change 'transfer' for 'call'</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>When using 'transfer', a fixed amount of gas is allocated for the execution of the called contract. This function do not allow for specifying a custom amount of gas or handling the return value, limiting their flexibility. By changing the 'transfer' function by 'call', developers can optimize gas usage, handle exceptions, and react accordingly based on the return value.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract transfer inside the function transfer (Line: 105)</p><pre>  function collectEther() public {
      msg.sender.transfer(this.balance);
  }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Delegatecall vulnerability</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Delegatecall is a low-level function that allows a contract to execute code from another contract while preserving the calling contract's storage and context. If an attacker can manipulate the delegatecall to execute malicious code, they may be able to manipulate the state of the calling contract or execute unauthorized operations. The attacker can potentially override important contract functions, bypass access controls, or even take control of the contract's execution flow. This can result in financial losses, unauthorized access, or other malicious activities.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract delegatecall inside the function delegatecall (Line: 142)</p><pre>    function withdraw() {
        withdrawalCounter += 1;
        // calculate the fibonacci number for the current withdrawal user
        // this sets calculatedFibNumber
        require(fibonacciLibrary.delegatecall(fibSig, withdrawalCounter));
        msg.sender.transfer(calculatedFibNumber * 1 ether);
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Save Gas: change 'transfer' for 'call'</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>When using 'transfer', a fixed amount of gas is allocated for the execution of the called contract. This function do not allow for specifying a custom amount of gas or handling the return value, limiting their flexibility. By changing the 'transfer' function by 'call', developers can optimize gas usage, handle exceptions, and react accordingly based on the return value.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract transfer inside the function transfer (Line: 143)</p><pre>    function withdraw() {
        withdrawalCounter += 1;
        // calculate the fibonacci number for the current withdrawal user
        // this sets calculatedFibNumber
        require(fibonacciLibrary.delegatecall(fibSig, withdrawalCounter));
        msg.sender.transfer(calculatedFibNumber * 1 ether);
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Delegatecall vulnerability</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>Delegatecall is a low-level function that allows a contract to execute code from another contract while preserving the calling contract's storage and context. If an attacker can manipulate the delegatecall to execute malicious code, they may be able to manipulate the state of the calling contract or execute unauthorized operations. The attacker can potentially override important contract functions, bypass access controls, or even take control of the contract's execution flow. This can result in financial losses, unauthorized access, or other malicious activities.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract delegatecall inside the function delegatecall (Line: 148)</p><pre>    function() public {
        require(fibonacciLibrary.delegatecall(msg.data));
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Save Gas: change 'transfer' for 'call'</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>When using 'transfer', a fixed amount of gas is allocated for the execution of the called contract. This function do not allow for specifying a custom amount of gas or handling the return value, limiting their flexibility. By changing the 'transfer' function by 'call', developers can optimize gas usage, handle exceptions, and react accordingly based on the return value.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract transfer inside the function transfer (Line: 174)</p><pre>    function sellTokens(uint tokens) public {
        require(balances[msg.sender] >= tokens);
        uint eth = tokens/tokensPerEth; 
        balances[msg.sender] -= tokens;
        msg.sender.transfer(eth*weiPerEth); //
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Save Gas: change 'transfer' for 'call'</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>When using 'transfer', a fixed amount of gas is allocated for the execution of the called contract. This function do not allow for specifying a custom amount of gas or handling the return value, limiting their flexibility. By changing the 'transfer' function by 'call', developers can optimize gas usage, handle exceptions, and react accordingly based on the return value.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract transfer inside the function transfer (Line: 196)</p><pre>     function _sendWinnings() {
         msg.sender.transfer(this.balance);
     }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Save Gas: change 'send' for 'call'</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>When using 'send', a fixed amount of gas is allocated for the execution of the called contract. This function do not allow for specifying a custom amount of gas or handling the return value, limiting their flexibility. By changing the 'send' function by 'call', developers can optimize gas usage, handle exceptions, and react accordingly based on the return value.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract send inside the function send (Line: 324)</p><pre>    function sendToWinner() public {
        require(!payedOut);
        winner.send(winAmount);
        payedOut = true;
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Save Gas: change 'send' for 'call'</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>When using 'send', a fixed amount of gas is allocated for the execution of the called contract. This function do not allow for specifying a custom amount of gas or handling the return value, limiting their flexibility. By changing the 'send' function by 'call', developers can optimize gas usage, handle exceptions, and react accordingly based on the return value.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract send inside the function send (Line: 330)</p><pre>    function withdrawLeftOver() public {
        require(payedOut);
        msg.sender.send(this.balance);
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Save Gas: change 'transfer' for 'call'</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>When using 'transfer', a fixed amount of gas is allocated for the execution of the called contract. This function do not allow for specifying a custom amount of gas or handling the return value, limiting their flexibility. By changing the 'transfer' function by 'call', developers can optimize gas usage, handle exceptions, and react accordingly based on the return value.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract transfer inside the function transfer (Line: 425)</p><pre>    function withdrawAll(address _recipient) public {
        require(tx.origin == owner);
        _recipient.transfer(this.balance); 
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Save Gas: change 'transfer' for 'call'</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>When using 'transfer', a fixed amount of gas is allocated for the execution of the called contract. This function do not allow for specifying a custom amount of gas or handling the return value, limiting their flexibility. By changing the 'transfer' function by 'call', developers can optimize gas usage, handle exceptions, and react accordingly based on the return value.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract transfer inside the function transfer (Line: 456)</p><pre>    function withdraw() public {
        require(balances[msg.sender] > 0);
        require(now > lockTime[msg.sender]);
        balances[msg.sender] = 0;
        msg.sender.transfer(balances[msg.sender]);
    }
</pre></div>
        </div>
    
                <div class="finding">
                    <div class="title">
                        <h2>Denial of Service (DoS) by for loop</h2>
                        <div class="warn">Warning</div>
                    </div>
                    <div class="info-row">
                        <h3>Description</h3>
                        <p>This vulnerability arises when a for loop is used to iterate over a large number of iterations, causing excessive computational overhead and consuming an excessive amount of gas. If the gas limit is exceeded, the function won't be executed and can lead to funds loss. If the iterations of the loop could surpass the maximum usage of gas, it is advisable to switch to a pull-over-push design. In this design, instead of using a loop, a public function is created to perform the functionality of each iteration, allowing each person to execute it.</p>
                    </div>
                    <div class="info-row">
                        <h3>Code Location</h3>
                        <p> The previous vulnerability has been found in the contract dos inside the function dos (Line: 390)</p><pre>  function initMultiowned(address[] _owners, uint _required) {
    m_numOwners = _owners.length + 1;
    m_owners[1] = uint(msg.sender);
    m_ownerIndex[uint(msg.sender)] = 1;
    for (uint i = 0; i < _owners.length; ++i)
    {
      m_owners[2 + i] = uint(_owners[i]);
      m_ownerIndex[uint(_owners[i])] = 2 + i;
    }
    m_required = _required;
  }
</pre></div>
        </div>
    
        </div>
        
        <div class="container" id="requires">
            <h2>Requires</h2>
            <div class="info-row">
                <h4>The following requires have been found several times. It is advisabe to replace them with a modifier</h4>
            </div>
        <div class="requires-grid">
    
                <div class="require_card">
                    <p> No require has been found repeated more than 3 times in the contract </p>
                </div>
        
            </div>
        </div>
    
        </body>
        </html>
    